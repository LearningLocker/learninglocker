<?php 
/*
|-----------------------------------------------------------------------------------
|
| Validate TinCan (xAPI) statements. You can read more about the
| standard here http://www.adlnet.gov/wp-content/uploads/2013/05/20130521_xAPI_v1.0.0-FINAL-correx.pdf
|
| This class covers version 1.0.0 and was built as part of the HT2 Learning Locker project.
| http://learninglocker.net
|
| @author Dave Tosh @davetosh
| @copyright HT2 http://ht2.co.uk
| @license MIT http://opensource.org/licenses/MIT
|
|-----------------------------------------------------------------------------------
*/

namespace app\locker\statements;

class xAPIValidation {

  private $status     = 'passed'; //status of the submitted statement. passed or failed.
  private $errors     = array();  //error messages if validation fails
  private $statement  = '';     //the statement submitted
  private $authority  = '';     //the authority submitting the statement

  /*
  |----------------------------------------------------------------------------
  | Constructor
  |
  | @param  array   $statement    The statement.
  | @param  array   $authority      The authority storing statement. 
  |-----------------------------------------------------------------------------
  */
  public function __construct( $statement, $authority ){

    $this->statement = $statement;
    $this->authority = $authority;
    
  }

  /*
  |----------------------------------------------------------------------------
  | Validator
  |
  | Run a full validation on submitted statement.
  |
  | @return array An array containing status, errors (if any) and the statement
  |----------------------------------------------------------------------------
  */
  public function runValidation() {

    //if getting started fails, don't continue with validation
    if( $this->getStarted() ){

      $this->validateId();
      $this->validateActor();
      $this->validateAuthority();
      $this->validateVerb();
      $this->validateObject();
      $this->validateContext();
      $this->validateTimestamp();
      $this->validateStored();
      $this->validateResult();
      $this->validateVersion();
      $this->validateAttachments();

    }

    return array( 'status'    => $this->status, 
            'errors'    => $this->errors,
            'statement' => $this->statement );

  }

  /*
  |----------------------------------------------------------------------------
  | Assertion Checker
  |
  | Checks if an assertion is true
  | Sets a status (default 'failed') and pushed an error on failure/false
  |
  | @param  boolean $assertion    The boolean we are testing
  | @param  string  $fail_error   The string to push into the errors array
  | @param  string  $fail_status  The string to set the status to
  | @return boolean           Whether we the assertion passed the test
  |----------------------------------------------------------------------------
  */
  public function assertionCheck( $assertion, $fail_error='There was an error', $fail_status='failed' ){

    if( !$assertion ){
      $this->setError( $fail_error, $fail_status );
      return false;
    }

    return true;
  }

  /*
  |----------------------------------------------------------------------------
  | Set errors and status
  |
  | Used to set the statement status and any errors.
  |
  | @param  string  $fail_error   The string to push into the errors array
  | @param  string  $fail_status  The string to set the status to
  |----------------------------------------------------------------------------
  */
  private function setError( $fail_error='There was an error', $fail_status='failed' ){
    $this->status   = $fail_status;
    $this->errors[] = $fail_error;
  }

  /*
  |----------------------------------------------------------------------------
  | Validate the ID.
  |
  | Must be generated by the LRS if statement is received without one. 
  | Id's should be provided by the Activity provider.
  |----------------------------------------------------------------------------
  */
  public function validateId(){
    if( empty( $this->statement['id'] ) ){
      $this->statement['id'] = $this->makeUUID();
    }
  }

  /*
  |----------------------------------------------------------------------------
  | Validate actor.
  | 
  | This is mandatory.
  |
  | Actor ObjectType can be a 'group' or 'agent' - check and verify for both.
  |
  | ObjectType and Name are not required. Functional identifier is required.
  |
  | Functional identiers can be one of four things:
  | 1) mbox       (mailto IRI)  mailto:email_address
  | 2) mbox_sha1sum (string)    sha1 hash of mailto IRI
  | 3) OpenID     (url)
  | 4) account    (object)    homePage and name (URL and String). The name can be account number or text 
  |
  | Requirements
  |
  | If OpenID is used, use that and not an account (if an account is submitted).
  | Each group must be treated unique, even if it contains identical list of members.
  | Group members can only be agents. Form: Functional identifier: the value.
  | 
  | • An Agent MUST be identified by one (1) of the four types of Inverse Functional Identifiers (see 
  | 4.1.2.3 Inverse Functional Identifier). 
  | • An Agent MUST NOT include more than one (1) Inverse Functional Identifier. 
  | • An Agent SHOULD NOT use inverse functional identifiers that are also used as a Group identifier. 
  |
  | Group requirements
  |
  | • An anonymous Group MUST include a 'member' property listing constituent Agents. 
  | • An anonymous Group MUST NOT contain Group Objects in the 'member' property. 
  | • An anonymous Group MUST NOT include any Inverse Functional Identifiers. 
  |
  | • An identified Group MUST include exactly one (1) Inverse Functional Identifier. 
  | • An identified Group MUST NOT contain Group Objects in the 'member' property. 
  | • An identified Group SHOULD NOT use Inverse Functional Identifiers that are also used as Agent 
  | identifiers. 
  | 
  |----------------------------------------------------------------------------
  */
  public function validateActor(){

    //first check actor is set as it is required
    $actor_check = $this->assertionCheck(
          ( isset($this->statement['actor']) && 
            !empty($this->statement['actor']) && 
            is_array($this->statement['actor']) ),
          'The statement does not have actor set, which is required.');
    
    if( !$actor_check ) return false;

    $actor    = $this->statement['actor'];
    $actor_keys = array_keys($actor);

    //check, if objectType is set, that it is either Group or Agent
    if( isset($actor['objectType'] ) ){

      $member_check = $this->assertionCheck(
          ( $actor['objectType'] == 'Agent' || $actor['objectType'] == 'Group' ),
          'The objectType is invalid. It must be a string Agent or Group.');

      if( !$member_check ) return false;

    }

    //Check that one functional identifier exists and is permitted
    $identifier_valid = $this->validIdentifier( $actor_keys );

    if( $actor['objectType'] == 'Group' ){

      //if objectType Group and no functional identifier: unidentified group
      if( $identifier_valid === false ){
        //Unidentified group so it must have an array containing at least one member
        $member_check = $this->assertionCheck(
            ( isset($actor['member']) && is_array($actor['member']) ),
            'As Actor objectType is Group, it must contain a members array.');

        if( !$member_check ) return false;
      }else{
        //identified group
        //check that the identifier given is in the correct format
        $validate_identifiers = $this->validateIdentifiers( $actor );
      }

    }else{

      //if not a group, then it is an Agent, or not set so needs a valid
      //functional identifier
      if( $identifier_valid === false ){
        $this->setError( 'The functional identifier is not valid.' );
        return false;
      }

      //check that the identifier given is in the correct format
      $validate_identifiers = $this->validateIdentifiers( $actor );

    }

  }

  /**
   * Check to make sure an valid identifier has been included in the statement.
   *
   * @param $actor_keys (array) The array of actor keys to validate
   * @return boolean 
   *
   **/
  public function validIdentifier( $actor_keys ){

    $identifier_valid     = false;
    $count          = 0;
    $functional_identifiers = array('mbox', 'mbox_sha1sum', 'openID', 'account');

    //check functional identifier exists and is valid
    foreach( $actor_keys as $k ){
      if( in_array($k, $functional_identifiers) ){
        $identifier_valid = true;
        $count++; //increment counter so we can check only one identifier is present
      }
    }

    //only allow one identifier
    if( $count > 1 ){
      $identifier_valid = false;
      $this->setError( 'A statement can only set one functional identifier.' ); 
    }
    
    return $identifier_valid;
  }

  /**
   * Validate the 4 allowed functional identifiers for an actor.
   *
   * @param $actor (array) An array containing the actor.
   * @return boolean 
   *
   **/
  public function validateIdentifiers( $actor ){
    
    if( isset($actor['mbox']) ){
      $mbox_format = substr($actor['mbox'], 0, 7);
      if( $mbox_format != 'mailto:'){
        $this->setError( 'The functional identifier - mbox - is not in a valid format.' );  
        return false;
      }
      return true;
    }

    if( isset($actor['openID']) ){
      //for now we just check it is a url / @todo check it is really an openID?
      if(!filter_var($actor['openID'], FILTER_VALIDATE_URL)){
        $this->setError( 'The functional identifier - openID - is not in a valid format.' );  
        return false;
      }
      return true;
    }

    if( isset($actor['mbox_sha1sum']) ){
      //for now just check it is a string
      if( !is_string( $actor['mbox_sha1sum'] ) ){
        $this->setError( 'The functional identifier - mbox_sha1sum - is not in a valid format.' );  
        return false;
      }
      return true;
    }

    if( isset($actor['account']) ){
      //for now just check it is actually an object
      if( !is_object( $actor['account'] ) ){
        $this->setError( 'The functional identifier - account - is not in a valid format.' ); 
        return false;
      }
      return true;
    }

  }

  /*
  |----------------------------------------------------------------------------
  | Validate authority.
  |
  | Mandatory.
  |
  | Requirements
  |
  | • Authority MUST be an Agent, except in 3-legged OAuth, where it must be a Group with two 
  | Agents. The two Agents represent an application and user together.
  | • The LRS MUST include the user as an Agent as the entire authority if the user connects directly 
  | (using HTTP Basic Authentication) or is included as part of a Group. 
  | • The LRS MUST ensure that all Statements stored have an authority. 
  | • The LRS SHOULD overwrite the authority on all stored received Statements, based on the 
  | credentials used to send those Statements.
  | • The LRS MAY identify the user with any of the legal identifying properties if a user connects 
  | directly (using HTTP Basic Authentication) or a part of a 3-legged OAuth.
  |
  | @todo rework to handle 3-legged OAuth.
  | 
  | 
  |----------------------------------------------------------------------------
  */
  public function validateAuthority(){
    //Overwrite / Add. This assume basic http authentication for now. See @todo.
    $this->statement['authority'] = array(
      'name'         =>  $this->authority['name'],
      'mbox'         =>  'mailto:' . $this->authority['email'],
      'objectType'   =>  'Agent'
    );
  }

  /*
  |----------------------------------------------------------------------------
  | Validate verb.
  | 
  | Mandatory.
  | 
  | Contains: iD ( IRI ), display ( Language map )
  |
  | @todo check IRI is valid
  | 
  |----------------------------------------------------------------------------
  */
  public function validateVerb(){

    $verb  = $this->statement['verb'];
    $count = count($verb);

    //first check there are only two keys
    if( $count != 2 ){
      $this->setError( 'failed', 'A verb can only contain two keys: Id and display.' );   
      return false;
    }else{
      //now check the keys are id and display
      if ( !array_key_exists('id', $verb) || !array_key_exists('display', $verb)){
        $this->setError( 'A verb can only contain two keys: Id and display.' );
        return false;
      }
    }

    return true;

  }

  /*
  |----------------------------------------------------------------------------
  | Validate object.
  |
  | Mandtory
  | 
  | The Object of a Statement can be an Activity, Agent/Group, Sub-Statement, or 
  | Statement Reference. 
  |
  | If no objectType set - assume Activity
  | 
  | When objectType = Activity
  |
  | Contains id (IRI - required) and definition ( object )
  | Definition can contain: name, description, type (uri e.g. type: http://....), moreInfo, extensions
  | 
  | Requirements
  | 
  | • An LRS MUST ignore any information which indicates two authors or organizations may have 
  | used the same Activity id. 
  | • An LRS MUST NOT treat references to the same id as references to different Activities. 
  | • Upon receiving a Statement with an Activity Definition that differs from the one stored, an LRS 
  | SHOULD decide whether it considers the Activity Provider to have the authority to change the 
  | definition and SHOULD update the stored Activity Definition accordingly if that decision is positive. 
  | • An LRS MAY accept small corrections to the Activity‟s definition. For example, it would be okay 
  | for an LRS to accept spelling fixes, but it may not accept changes to correct responses.
  |
  | When objectType = Statement
  |
  | Contains id (UUID of a statement)
  | • A Statement Reference MUST specify an "objectType" property with the value "StatementRef". 
  | • A Statement Reference MUST set the "id" property to the UUID of a Statement. 
  |
  | Sub-statements
  |
  | • A Sub-Statement MUST specify an "objectType" property with the value "SubStatement". 
  | • A Sub-Statement MUST be validated as a Statement in addition to other Sub-Statement 
  | requirements. 
  | • A Sub-Statement MUST NOT have the "id", "stored", "version" or "authority" properties. 
  | • A Sub-Statement MUST NOT contain a Sub-Statement of their own, i.e., cannot be nested. 
  | 
  |----------------------------------------------------------------------------
  */
  public function validateObject(){

    $object_check = $this->assertionCheck(
          ( isset($this->statement['object']) && is_array($this->statement['object']) ),
          'The statement object is not correctly formatted.');
    
    if( !$object_check ) return false;

    $object = $this->statement['object'];

    $object_type_valid_keys = array('Activity', 
                    'Group', 
                    'Agent', 
                    'SubStatement', 
                    'StatementRef');

    //find out what type of object it is as that will inform next steps
    if( isset($object['objectType']) ){

      $object_type = $object['objectType'];

      //check objectType is valid.
      $object_type_valid = $this->checkKeys( array($object_type), $object_type_valid_keys );

      //if there is an invalid key, exit here
      if( $object_type_valid === false ){
        $this->setError( 'The objectType is not valid.' );
        return false;
      }

    }else{
      $object_type = 'Activity'; //this is the default if nothing defined.
    }

    //depending on the objectType, validate accordingly.
    $object_keys   = array_keys( $object );

    if( $object_type == 'Activity' || $object_type == 'Agent' || $object_type == 'Group' ){

      $activity_valid_keys = array('objectType', 
                     'id', 
                     'definition');

      //check activity object only has valid keys.
      $object_valid = $this->checkKeys($object_keys, $activity_valid_keys);

      if( $object_valid === false ){
        $this->setError( 'The object has an invalid property.' );
        return false;
      }

      //check if key exists as it is required.
      if( !isset($object['id']) ){
        $this->setError( 'The object\'s id has not been set and is required.' );
        return false;
      }

      //now check object keys are the correct format

      //@todo check id is an IRI
      //if( !is_array($object['id']) ){
      //  $this->status   = 'failed';
      //  $this->errors[] = 'Object: id need to be an IRI.';
      //}

      //check definition, if set, is an object
      if( isset($object['definition']) ){
        //\App::abort(400, $object['definition']);
        if( !is_array($object['definition']) ){
          $this->setError( 'Object: definition needs to be an object.' );
        }

        $definition = $object['definition'];
        $definition_keys = array_keys( $definition );

        $definition_valid_keys = array('name', 
                         'description', 
                         'type', 
                         'moreInfo', 
                         'extensions', 
                         'interactionType',
                         'correctResponsesPattern',
                         'choices',
                         'scale',
                         'source',
                         'target',
                         'steps');

        //check activity object definition only has valid keys.
        $definition_valid = $this->checkKeys($definition_keys, $definition_valid_keys);

        if( $definition_valid === false ){
          $this->setError( 'The object\'s definition has an invalid property.' );
          return false;
        }

        //now check definition keys are formated correctly
        if( isset($definition['name']) ){
          if( !is_array($definition['name']) ){
            $this->setError( 'Object: definition: name needs to be a language map.' );
          }
        }

        if( isset($definition['description']) ){
          if( !is_array($object['definition']['description']) ){
            $this->setError( 'Object: definition: description needs to be a language map.' );
          }
        }

        if( isset($definition['type']) ){
          if( !filter_var($object['definition']['type'], FILTER_VALIDATE_URL) ){
            $this->setError( 'Object: definition: type needs to be a IRL.' );
          }
        }

        if( isset($definition['moreInfo']) ){
          //@todo - not sure what an IL is
        }

        if( isset($definition['interactionType']) ){
          //check to see it type is set, if not, set to http://adlnet.gov/expapi/activities/cmi.interaction
          $allowed_interaction_types = array('choice',
                             'sequencing',
                             'Likert',
                             'Matching',
                             'Performance',
                             'true-false',
                             'fill-in',
                             'numeric',
                             'other');

          if( !in_array($definition['interactionType'], $allowed_interaction_types) ){
            $this->setError( 'Object: definition: interactionType is not valid.' );
          } 
        }

        if( isset($definition['correctResponsesPattern']) ){
          //check to see it type is set, if not, set to http://adlnet.gov/expapi/activities/cmi.interaction
          if( !is_array($definition['correctResponsesPattern']) ){
            $this->setError( 'Object: definition: correctResponsesPattern needs to be an array.' );
          }
        }

        if( isset($definition['choices'], $definition['scale'], $definition['source'], $definition['target'],$definition['steps']) ){

          $check_valid_keys = array('id', 'description');

          $loop = array('choices','scale','source','target','steps');

          foreach( $loop as $l ){

            //check activity object definition only has valid keys.
            $is_valid = $this->checkKeys($definition[$l], $check_valid_keys);

            if( $definition_valid === false ){
              $this->setError( 'Object: definition: It has an invalid property.' );
              return false;
            }

            //these components all contain an id and description
            if ( !array_key_exists('id', $definition[$l]) || !array_key_exists('description', $definition[$l])){
              $this->setError( 'Object: definition: It needs to be an array with keys id and description.' );
            }

          }
        }

        if( isset($definition['extensions']) ){
          if( !is_array($definition['extensions']) ){
            $this->setError( 'Object: definition: extensions need to be an object.' );
          }
        }
      }
          
    }elseif( $object_type == 'StatementRef' ){
      //Will only have objectType and id where id is a statement UUID.
      $id = $object['id'];
      if( isset($id) ){
        //check it is in a valid UUID format
        if( !preg_match('/^\{?[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}\}?$/i', $id) ){
          $this->setError( 'Object of type StatementRef needs an id with a valid UUID.' );
        }
      }else{
        $this->setError( 'Object of type StatementRef needs to contain the UUID of a statement.' );
        return false;
      }

    }elseif( $object_type == 'SubStatement' ){
      //@todo validate sub-statement
        
      //remove "id", "stored", "version" or "authority" if exist
      unset($object['id']);
      unset($object['stored']);
      unset($object['version']);
      unset($object['authority']);

      //check object type is not SubStatement as nesting is not permitted
      if( $object['objectType'] == 'SubStatement' ){
        $this->setError( 'A SubStatement cannot contain a nested statement.' );
        return false;
      }

    }else{
      //finished.
    }

  }

  /*
  |----------------------------------------------------------------------------
  | Validate context.
  |
  | Optional.
  | 
  | Context provides extra information about the statement. It can have the 
  | following elements:
  |
  | 1) Registration: UUID
  | 2) Instructor: Agent (of group) - if not set as the Actor of statement.
  | 3) Team: (group) - if not set as the actor of the statement.
  | 4) contextActivities: must be a valid type - parent, grouping, category, other.
  | 5) revision: (string)
  | 6) platform: (string)
  | 7) language: (string (as defined in RFC 5646)
  | 8) statement: Statement reference
  | 9) extensions
  |
  | Requirements
  |
  | • The revision property MUST NOT be used if the Statement's Object is an Agent or Group. 
  | • The platform property MUST NOT be used if the Statement's Object is an Agent or Group. 
  | • The language property MUST NOT be used if not applicable or unknown. 
  |
  | contextActivies requirements
  |
  | • Every key in the contextActivities Object MUST be one of parent, grouping, category, or other. 
  | • Every value in the contextActivities Object MUST be either a single Activity object or an array of 
  | Activity objects. 
  |
  | 
  |----------------------------------------------------------------------------
  */
  public function validateContext(){
    
    if( isset($this->statement['context']) ){

      $context_check = $this->assertionCheck(
          ( is_array($this->statement['context']) && !empty($this->statement['context']) ),
          'Context must be an array and can\'t be empty.');
    
      if( !$context_check ) return false;

      
      $context        = $this->statement['context'];
      $context_keys       = array_keys($context);
      $valid_context_keys = array('registration', 
                    'instructor', 
                    'team', 
                    'contextActivities', 
                    'revision', 
                    'platform',
                    'language',
                    'statement',
                    'extensions');

      //check all keys submitted are valid
      $context_valid = $this->checkKeys($context_keys, $valid_context_keys);

      //if there is an invalid key, exit here
      if( $context_valid === false ){
        $this->setError( 'There is an invalid property in context.' );
        return false;
      }

      //now check all main properties
      if( isset($context['registration']) ){
        if( !preg_match('/^\{?[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}\}?$/i', $context['registration']) ){
          $this->setError( 'Context: registration must be a UUID.' );
        }
      }

      if( isset($context['instructor']) ){
        if( !is_array($context['instructor']) ){
          $this->setError( 'Context: instructor must be an Agent object.' );
        }
      }

      if( isset($context['team']) ){
        if( !is_array($context['team']) ){
          $this->setError( 'Context: team must be an Group object.' );
        }
      }

      if( isset($context['contextActivities']) ){
        if( !is_array($context['contextActivities']) ){
          $this->setError( 'Context: contextActivities must be an object.' );
        }else{
          //check properties in contextActivies
          $contextActivies_valid        = true;
          $contextActivities_keys     = array_keys($context['contextActivities']);
          $valid_contextActivities_keys = array('parent', 
                              'grouping', 
                              'category', 
                              'other');
            //check all keys submitted are valid
          foreach( $contextActivities_keys as $k ){
            if( !in_array($k, $valid_contextActivities_keys) ){
              $contextActivies_valid = false;
            }
          }

          //if there is an invalid key, exit here
          if( $contextActivies_valid === false ){
            $this->setError( 'There is an invalid property in contextActivities.' );
            return false;
          }

          //now check all property keys contain an array
          //While the contextActivity may be an object on input, it must be stored as an array - so on each type we will check if an associative array has been passed and insert it into an array if needed
          if( isset($context['contextActivities']['parent']) ){
            if( !is_array($context['contextActivities']['parent']) ){
              $this->setError( 'Context: contextActivities: parent must be an object or array of objects.' );
            } else { 
              if( $this->isAssoc( $this->$context['contextActivities']['parent'] ) ){ 
                $this->statement['context']['contextActivities']['parent'] = array( $this->$context['contextActivities']['parent'] );
              }
            }
          }

          if( isset($context['contextActivities']['grouping']) ){
            if( !is_array($context['contextActivities']['grouping']) ){
              $this->setError( 'Context: contextActivities: grouping must be an object or array of objects.' );
            } else {
              if( $this->isAssoc( $this->$context['contextActivities']['grouping'] ) ){
                $this->statement['context']['contextActivities']['grouping'] = array( $this->$context['contextActivities']['grouping'] );
              }
            }
          }

          if( isset($context['contextActivities']['category']) ){
            if( !is_array($context['contextActivities']['category']) ){
              $this->setError( 'Context: contextActivities: category must be an object or array of objects.' );
            } else {
              if( $this->isAssoc( $this->$context['contextActivities']['category'] ) ){
                $this->statement['context']['contextActivities']['category'] = array( $this->$context['contextActivities']['category'] );
              }
            }
          }

          if( isset($context['contextActivities']['other']) ){
            if( !is_array($context['contextActivities']['other']) ){
              $this->setError( 'Context: contextActivities: other must be an object or array of objects.' );
            } else {
              if( $this->isAssoc( $this->$context['contextActivities']['other'] ) ){
                $this->statement['context']['contextActivities']['other'] = array( $this->$context['contextActivities']['other'] );
              }
            }
          }
        }
      }

      if( isset($context['revision']) ){
        //If Statement's Object is an Agent or Group, don't save
        $object_type = array('Agent', 'Group');
        if( !in_array($this->statement['object']['objectType'], $object_type) ){
          if( !is_string($context['revision']) ){
            $this->setError( 'Context: revision must be a string.' );
          }
        }
      }

      if( isset($context['platform']) ){
        //If Statement's Object is an Agent or Group, don't save
        $object_type = array('Agent', 'Group');
        if( !in_array($this->statement['object']['objectType'], $object_type) ){
          if( !is_string($context['platform']) ){
            $this->setError( 'Context: platform must be a string.' );
          }
        }
      }

      if( isset($context['language']) ){
        //@todo need to check language is valid rfc 5646 code, if not, reject it.
        if( !is_string($context['language']) ){
          $this->setError( 'Context: language must be a string.' );
        }
      }

      if( isset($context['statement']) ){
        if( !preg_match('/^\{?[A-Z0-9]{8}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{4}-[A-Z0-9]{12}\}?$/i', $context['statement']) ){
          $this->setError( 'Context: statement must be a UUID of the connected statement.' );
        }
      }

      if( isset($context['extensions']) ){
        if( !is_array($context['extensions']) ){
          $this->setError( 'Result: extensions must be an object.' );
        }
      }

    
    }


  }

  /*
  |----------------------------------------------------------------------------
  | Validate result.
  |
  | Optional.
  | 
  | There are 6 parts available for result: score, success, completion, response,
  | duration, extensions.
  | 
  | Score: object
  | Success: boolean
  | Completion: boolean
  | Response: string
  | Duration: ISO 8601 
  | Extension: object
  |
  | Requirements:
  |
  | Score
  | • The Score Object SHOULD include 'scaled' if a logical percent based score is known. 
  | • The Score Object SHOULD NOT be used for scores relating to progress or completion. Consider 
  | using an extension from an extension profile instead.
  | 
  |----------------------------------------------------------------------------
  */
  public function validateResult(){

    if( isset($this->statement['result']) ){

      $result_check = $this->assertionCheck(
          ( is_array($this->statement['result']) && !empty($this->statement['result']) ),
          'Result must be an array and can\'t be empty.');
    
      if( !$result_check ) return false;

      $result     = $this->statement['result'];
      $result_keys  = array_keys($result);//if result set, grab keys
      $valid_keys   = array('score', 
                  'success', 
                  'completion', 
                  'response', 
                  'duration', 
                  'extensions');

      //check all keys submitted are valid
      $result_valid = $this->checkKeys($result_keys, $valid_keys);

      //if there is an invalid key, exit here
      if( $result_valid === false ){
        $this->setError( 'There is an invalid key in result.' );
        return false;
      }

      //now check format of each key section
      if( isset($result['score']) ){
        if( !is_array($result['score']) ){
          $this->setError( 'Result: score must be an object.' );
        }else{
          //check contents of score
          $score_valid    = true;
          $valid_score_keys = array('scaled', 'raw', 'min', 'max');
          $score_keys     = array_keys($result['score']);
          //check all keys submitted are valid
          foreach( $score_keys as $k ){
            if( !in_array($k, $valid_score_keys) ){
              $score_valid = false;
            }
          }
          if( $score_valid === false ){
            $this->setError( 'There is an invalid key in the score object.' );
            return false;
          }
          //now check format of each score key
          if( isset($result['score']['scaled']) ){
            if( $result['score']['scaled'] > 1 || $result['score']['scaled'] < -1){
              $this->setError( 'Result: score: scaled must be between 1 and -1.' );
            }
          }
          if( isset($result['score']['max']) ){
            if( !is_numeric($result['score']['max']) ){
              $this->setError( 'Result: score: max must be a numeric value.' );
            }
            if( $result['score']['max'] < $result['score']['min'] ){
              $this->setError( 'Result: score: max must be greater than min.' );
            }
          }
          if( isset($result['score']['min']) ){
            if( !is_numeric($result['score']['min']) ){
              $this->setError( 'Result: score: min must be a numeric value.' );
            }
            if( isset($result['score']['max'])){
              if( $result['score']['min'] > $result['score']['max'] ){
                $this->setError( 'Result: score: min must be less than max.' );
              }
            }
          }
          if( isset($result['score']['raw']) ){
            if( !is_numeric($result['score']['raw']) ){
              $this->setError( 'Result: score: raw must be a numeric value.' );
            }
            if( isset($result['score']['max']) && isset($result['score']['min']) ){
              if( ($result['score']['raw'] > $result['score']['max']) || ($result['score']['raw'] < $result['score']['min']) ){
                $this->setError( 'Result: score: raw must be between max and min.' );
              }
            }
          }
        }
      }

      if( isset($result['completion']) ){
        if( !is_bool($result['completion']) ){
          $this->setError( 'Result: completion must be a boolean.' );
        }
      }

      if( isset($result['success']) ){
        if( !is_bool($result['success']) ){
          $this->setError( 'Result: success must be a boolean.' );
        }
      }

      if( isset($result['duration']) ){
        if( !is_numeric($result['duration']) ){
          $this->setError( 'Result: duration must be an integer.' );
        }
      }

      if( isset($result['response']) ){
        if( !is_string($result['response']) ){
          $this->setError( 'Result: response must be a string.' );
        }
      }

      if( isset($result['extensions']) ){
        if( !is_array($result['extensions']) ){
          $this->setError( 'Result: extensions must be an object.' );
        }
      }
    }
  }

  /*
  |----------------------------------------------------------------------------
  | Validate timestamp.
  |
  | Optional.
  | 
  | Must be in ISO 8601 format
  | It can be in the future as long as it is in a sub-statement.
  | Sent by the provider
  | 
  |----------------------------------------------------------------------------
  */
  public function validateTimestamp(){
    
    //does timestamp exist?
    if( isset($this->statement['timestamp']) ){
      $timestamp = $this->statement['timestamp'];
    }else{
      return false; //no timestamp set
    }

    //check format using http://www.pelagodesign.com/blog/2009/05/20/iso-8601-date-validation-that-doesnt-suck/
    if (!preg_match('/^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/', $timestamp) > 0) {
      $this->setError( 'Timestamp needs to be in ISO 8601 format.' );
      return false;
    } 

    //@todo is the timestamp in the future? If so, make sure it is include in a sub-statement only

    return true;

  }

  /*
  |----------------------------------------------------------------------------
  | Validate stored.
  | 
  | The LRS adds stored, so make sure it is not set in the statement received.
  | 
  |----------------------------------------------------------------------------
  */
  public function validateStored(){
  
    if( isset( $this->statement['stored'] ) ){
      unset( $this->statement['stored'] );
    }

  }

  /*
  |----------------------------------------------------------------------------
  | Validate version.
  | 
  | LRS MUST reject all Statements with a version specified that does not start
  | with "1.0.".
  | If no version available, add the version 1.0.0
  | 
  |----------------------------------------------------------------------------
  */
  public function validateVersion(){
  
    if( isset( $this->statement['version'] ) ){
      $result = $result = substr($this->statement['version'], 0, 4);
      if( $result != '1.0.' ){
        $this->setError( 'The statement has an invalid version.' );
        return false;
      }
    }else{
      $this->statement['version'] = '1.0.0';
    }

    return true;

  }

  /*
  |----------------------------------------------------------------------------
  | Validate attachments.
  | 
  | Optional.
  |
  | Available properties: usageType (IRI, required), display (Language map, required), 
  | description (language map), contentType (Internet Media Type, required), length (Int, required), 
  | sha2 (base64, required), fileUrl (IRL)
  |
  | Requirements
  |
  | o When receiving a PUT or POST with a document type of "application/json" 
  | o An LRS MUST accept batches of Statements which contain either no attachment Objects, 
  | or only attachment Objects with a populated fileUrl; 
  | • Otherwise: 
  | o An LRS MUST accept batches of Statements via the Statements resource PUT or POST 
  | that contain attachments in the Transmission Format described above. 
  | o An LRS MUST reject batches of Statements having attachments that neither contain a 
  | fileUrl nor match a received attachment part based on their hash. 
  | o An LRS SHOULD assume a Content-Transfer-Encoding of binary for attachment parts
  | 
  |----------------------------------------------------------------------------
  */
  public function validateAttachments(){
  
    if( isset($this->statement['attachment']) ){

      if( is_array($this->statement['attachment']) ){

        //check attachment properties
        $attachment        = $this->statement['attachment'];
        $attachment_keys       = array_keys($attachment);
        $valid_attachment_keys = array('usageType', 
                         'display', 
                         'description', 
                         'contentType', 
                         'length', 
                         'sha2',
                         'fileUrl');

        //check all keys are valid
        $attachment_valid = $this->checkKeys($attachment_keys, $valid_attachment_keys);

        //if there is an invalid key, exit here
        if( $attachment_valid === false ){
          $this->setError( 'There is an invalid property in the attachment.' );
          return false;
        }

        //now we know that the keys are valid, let's check the required keys are present
        if (isset($attachment['usageType'], $attachment['display'], 
                    $attachment['contentType'], $attachment['length'], $attachment['sha2'])) {

          foreach( $attachment as $key => $value ){
            switch( $key ){
              case 'usageType':
              //@todo need to properly validate a IRI
              if( !is_string($value) ){
                $this->setError( 'Attachment: usageType is not a valid IRI.' );
              }
              break;
              case 'display':
              //@todo need to properly detect valid language map
              if( !is_array($value) ){
                $this->setError( 'Attachment: display is not a valid language map.' );
              }
              break;
              case 'contentType':
              //@todo need to properly detect valid Internet Media Type
              //if( !is_array($attachment['contentType']) ){
              // $this->setError( 'Attachment: contentType is not a valid Internet Media Type.' );
              //}
              break;
              case 'length':
              if( !is_integer($value) ){
                $this->setError( 'Attachment: length is not a valid integer.' );
              }
              break;
              case 'sha2':
              if( base64_encode(base64_decode($value)) !== $value ){
                $this->setError( 'Attachment: sha2 is not valid base64 encoded.' );
              }
              break;
              case 'fileUrl':
              //@todo need to properly validate a IRL
              if( !filter_var($value, FILTER_VALIDATE_URL) ){
                $this->setError( 'Attachment: usageType is not a valid IRI.' );
              }
              break;
              case 'description':
              //@todo need to properly detect valid language map
              if( !is_array($value) ){
                $this->setError( 'Attachment: description is not a valid language map.' );
              }
              break;
            }
          }
      
        }else{

          //check the fileUrl is not available, if not, reject statement
          if( !isset($attachment['fileUrl']) ){
            $this->setError( 'Attachment needs to have usageType, display, contentType, length and sha2 define. Or, fileUrl.' );
            return false;
          }else{
            //validate fileUrl
            //@todo need to properly validate a IRL
            if( !filter_var($attachment['fileUrl'], FILTER_VALIDATE_URL) ){
              $this->setError( 'Attachment: fileUrl is not a valid IRL.' );
            }
          }
        }

      }else{
        //Do we reject the statement or just remove the ill-formatted attachment property?

        //$this->status   = 'failed';
        //$this->errors[] = 'Statement attachment must be an array.';
        
        unset( $this->statement['attachement'] );
        return false;
      }

    }

  }

  /*
  |----------------------------------------------------------------------------
  | General validation.
  | 
  | • The LRS MUST reject Statements 
  |   o with any null values (except inside extensions). 
  |   o with strings where numbers are required, even if those strings contain numbers. 
  |   o with strings where booleans are required, even if those strings contain Booleans. 
  |   o with any non-format-following key or value, including the empty string, where a. string with 
  |   a particular format (such as mailto IRI, UUID, or IRI) is required. 
  |   o where the case of a key does not match the case specified in the standard. 
  |   o where the case of a value restricted to enumerated values does not match an 
  |   enumerated value given in the standard exactly.
  | • The LRS MUST reject Statements containing IRL, IRI, or IRI values without a scheme. 
  | 
  |----------------------------------------------------------------------------
  */
  public function getStarted(){

    //check statement is an array and not empty
    $statement_check = $this->assertionCheck(
          ( isset($this->statement) && !empty($this->statement) && is_array($this->statement) ),
          'The statement doesn\'t exist or is not in the correct format.');
    
    if( !$statement_check ) return false;
  
    //check statement only contains allowed properties
    $statement_keys     = array_keys( $this->statement );
    $valid_statement_keys = array('id', 
                    'actor', 
                    'verb', 
                    'object', 
                    'result', 
                    'context',
                    'timestamp',
                    'stored',
                    'authority',
                    'version',
                    'attachment');

    //check all keys are valid
    $statement_valid = $this->checkKeys($statement_keys, $valid_statement_keys);
  
    //if there is an invalid key, exit here
    if( $statement_valid === false ){
      $this->setError( 'There is an invalid core property in this statement.' );
      return false;
    }

    return true;

  }

  /**
   * Check submitted keys vs allowed keys.
   *
   * @param $keys (array) The array of keys to validate
   * @param $valid_keys (array) The array of valid keys to check against.
   * @return boolean 
   *
   **/
  public function checkKeys($keys, $valid_keys){
    $valid = true;
    foreach( $keys as $k ){
      if( !in_array($k, $valid_keys) ){
        $valid = false;
      }
    }
    return $valid;
  }

  /*
  |----------------------------------------------------------------------------
  | Generate unique UUID
  |----------------------------------------------------------------------------
  */
  public function makeUUID(){
    return sprintf( '%04x%04x-%04x-%04x-%04x-%04x%04x%04x',
      // 32 bits for "time_low"
      mt_rand( 0, 0xffff ), mt_rand( 0, 0xffff ),

      // 16 bits for "time_mid"
      mt_rand( 0, 0xffff ),

      // 16 bits for "time_hi_and_version",
      // four most significant bits holds version number 4
      mt_rand( 0, 0x0fff ) | 0x4000,

      // 16 bits, 8 bits for "clk_seq_hi_res",
      // 8 bits for "clk_seq_low",
      // two most significant bits holds zero and one for variant DCE1.1
      mt_rand( 0, 0x3fff ) | 0x8000,

      // 48 bits for "node"
      mt_rand( 0, 0xffff ), mt_rand( 0, 0xffff ), mt_rand( 0, 0xffff )
    );
  }

  /*
  |-------------------------------------------------------------------------------
  | Regex to validate an IRI
  | Regex found here http://stackoverflow.com/questions/161738/what-is-the-best-regular-expression-to-check-if-a-string-is-a-valid-url
  |-------------------------------------------------------------------------------
  */
  private function validateIRI(){
    $regex = "/^[a-z](?:[-a-z0-9\+\.])*:(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4}:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+[-a-z0-9\._~!\$&'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=@])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}|\x{100000}-\x{10FFFD}\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&'\(\)\*\+,;=:@])|[\/\?])*)?$/i";
  }

  /*
  |-------------------------------------------------------------------------------
  | Regex to validate Internet media type
  |-------------------------------------------------------------------------------
  */
  private function validateInternetMediaType(){
    
  }

  /*
  |-------------------------------------------------------------------------------
  | Regex to validate language map
  |-------------------------------------------------------------------------------
  */
  private function validateLanguageMap(){
    
  }


  /**
   * Returns true if an array is associative 
   * @param  Array  $arr 
   * @return boolean      
   */
  private function isAssoc($arr)
  {
    return array_keys($arr) !== range(0, count($arr) - 1);
  }

}
